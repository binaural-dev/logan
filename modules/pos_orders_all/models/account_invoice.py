# -*- coding: utf-8 -*-
# Part of BrowseInfo. See LICENSE file for full copyright and licensing details.
import logging
from datetime import timedelta
from functools import partial

import psycopg2
import pytz

from odoo import api, fields, models, tools, _
from odoo.tools import float_is_zero
from odoo.exceptions import UserError
from odoo.http import request
import odoo.addons.decimal_precision as dp
from functools import partial


_logger = logging.getLogger(__name__)

class AccountInvoiceInherit(models.Model):
	_inherit = "account.move"

	pos_order_id = fields.Many2one('pos.order',string="POS order")

	def _recompute_tax_lines(self, recompute_tax_base_amount=False):
		''' Compute the dynamic tax lines of the journal entry.

		:param lines_map: The line_ids dispatched by type containing:
			* base_lines: The lines having a tax_ids set.
			* tax_lines: The lines having a tax_line_id set.
			* terms_lines: The lines generated by the payment terms of the invoice.
			* rounding_lines: The cash rounding lines of the invoice.
		'''
		self.ensure_one()
		in_draft_mode = self != self._origin

		def _serialize_tax_grouping_key(grouping_dict):
			''' Serialize the dictionary values to be used in the taxes_map.
			:param grouping_dict: The values returned by '_get_tax_grouping_key_from_tax_line' or '_get_tax_grouping_key_from_base_line'.
			:return: A string representing the values.
			'''
			return '-'.join(str(v) for v in grouping_dict.values())

		def _compute_base_line_taxes(base_line):
			''' Compute taxes amounts both in company currency / foreign currency as the ratio between
			amount_currency & balance could not be the same as the expected currency rate.
			The 'amount_currency' value will be set on compute_all(...)['taxes'] in multi-currency.
			:param base_line:   The account.move.line owning the taxes.
			:return:            The result of the compute_all method.
			'''
			move = base_line.move_id
			line_discount = 0;

			if move.is_invoice(include_receipts=True):
				handle_price_include = True
				sign = -1 if move.is_inbound() else 1
				quantity = base_line.quantity
				is_refund = move.move_type in ('out_refund', 'in_refund')
				if base_line.pos_order_id and base_line.pos_order_id.discount_type == "Fixed":
					line_discount = base_line.price_unit - base_line.discount

				if  base_line.pos_order_id and base_line.pos_order_id.discount_type == "Fixed":
					price_unit_wo_discount = sign * line_discount
				else:
					price_unit_wo_discount = sign * base_line.price_unit * (1 - (base_line.discount / 100.0))
			

			else:
				handle_price_include = False
				quantity = 1.0
				tax_type = base_line.tax_ids[0].type_tax_use if base_line.tax_ids else None
				is_refund = (tax_type == 'sale' and base_line.debit) or (tax_type == 'purchase' and base_line.credit)
				price_unit_wo_discount = base_line.amount_currency

			return base_line.tax_ids._origin.with_context(force_sign=move._get_tax_force_sign()).compute_all(
				price_unit_wo_discount,
				currency=base_line.currency_id,
				quantity=quantity,
				product=base_line.product_id,
				partner=base_line.partner_id,
				is_refund=is_refund,
				handle_price_include=handle_price_include,
				include_caba_tags=move.always_tax_exigible,
			)

		taxes_map = {}

		# ==== Add tax lines ====
		to_remove = self.env['account.move.line']
		for line in self.line_ids.filtered('tax_repartition_line_id'):
			grouping_dict = self._get_tax_grouping_key_from_tax_line(line)
			grouping_key = _serialize_tax_grouping_key(grouping_dict)
			if grouping_key in taxes_map:
				# A line with the same key does already exist, we only need one
				# to modify it; we have to drop this one.
				to_remove += line
			else:
				taxes_map[grouping_key] = {
					'tax_line': line,
					'amount': 0.0,
					'tax_base_amount': 0.0,
					'grouping_dict': False,
				}
		if not recompute_tax_base_amount:
			self.line_ids -= to_remove

		# ==== Mount base lines ====
		for line in self.line_ids.filtered(lambda line: not line.tax_repartition_line_id):
			# Don't call compute_all if there is no tax.
			if not line.tax_ids:
				if not recompute_tax_base_amount:
					line.tax_tag_ids = [(5, 0, 0)]
				continue

			compute_all_vals = _compute_base_line_taxes(line)

			# Assign tags on base line
			if not recompute_tax_base_amount:
				line.tax_tag_ids = compute_all_vals['base_tags'] or [(5, 0, 0)]

			for tax_vals in compute_all_vals['taxes']:
				grouping_dict = self._get_tax_grouping_key_from_base_line(line, tax_vals)
				grouping_key = _serialize_tax_grouping_key(grouping_dict)

				tax_repartition_line = self.env['account.tax.repartition.line'].browse(tax_vals['tax_repartition_line_id'])
				tax = tax_repartition_line.invoice_tax_id or tax_repartition_line.refund_tax_id

				taxes_map_entry = taxes_map.setdefault(grouping_key, {
					'tax_line': None,
					'amount': 0.0,
					'tax_base_amount': 0.0,
					'grouping_dict': False,
				})
				taxes_map_entry['amount'] += tax_vals['amount']
				taxes_map_entry['tax_base_amount'] += self._get_base_amount_to_display(tax_vals['base'], tax_repartition_line, tax_vals['group'])
				taxes_map_entry['grouping_dict'] = grouping_dict

		# ==== Pre-process taxes_map ====
		taxes_map = self._preprocess_taxes_map(taxes_map)

		# ==== Process taxes_map ====
		for taxes_map_entry in taxes_map.values():
			# The tax line is no longer used in any base lines, drop it.
			if taxes_map_entry['tax_line'] and not taxes_map_entry['grouping_dict']:
				if not recompute_tax_base_amount:
					self.line_ids -= taxes_map_entry['tax_line']
				continue

			currency = self.env['res.currency'].browse(taxes_map_entry['grouping_dict']['currency_id'])

			# Don't create tax lines with zero balance.
			if currency.is_zero(taxes_map_entry['amount']):
				if taxes_map_entry['tax_line'] and not recompute_tax_base_amount:
					self.line_ids -= taxes_map_entry['tax_line']
				continue

			# tax_base_amount field is expressed using the company currency.
			tax_base_amount = currency._convert(taxes_map_entry['tax_base_amount'], self.company_currency_id, self.company_id, self.date or fields.Date.context_today(self))

			# Recompute only the tax_base_amount.
			if recompute_tax_base_amount:
				if taxes_map_entry['tax_line']:
					taxes_map_entry['tax_line'].tax_base_amount = tax_base_amount
				continue

			balance = currency._convert(
				taxes_map_entry['amount'],
				self.company_currency_id,
				self.company_id,
				self.date or fields.Date.context_today(self),
			)
			to_write_on_line = {
				'amount_currency': taxes_map_entry['amount'],
				'currency_id': taxes_map_entry['grouping_dict']['currency_id'],
				'debit': balance > 0.0 and balance or 0.0,
				'credit': balance < 0.0 and -balance or 0.0,
				'tax_base_amount': tax_base_amount,
			}

			if taxes_map_entry['tax_line']:
				# Update an existing tax line.
				taxes_map_entry['tax_line'].update(to_write_on_line)
			else:
				create_method = in_draft_mode and self.env['account.move.line'].new or self.env['account.move.line'].create
				tax_repartition_line_id = taxes_map_entry['grouping_dict']['tax_repartition_line_id']
				tax_repartition_line = self.env['account.tax.repartition.line'].browse(tax_repartition_line_id)
				tax = tax_repartition_line.invoice_tax_id or tax_repartition_line.refund_tax_id
				taxes_map_entry['tax_line'] = create_method({
					**to_write_on_line,
					'name': tax.name,
					'move_id': self.id,
					'partner_id': line.partner_id.id,
					'company_id': line.company_id.id,
					'company_currency_id': line.company_currency_id.id,
					'tax_base_amount': tax_base_amount,
					'exclude_from_invoice_tab': True,
					**taxes_map_entry['grouping_dict'],
				})

			if in_draft_mode:
				taxes_map_entry['tax_line'].update(taxes_map_entry['tax_line']._get_fields_onchange_balance(force_computation=True))


class AccountInvoiceLineInherit(models.Model):
	_inherit = "account.move.line"

	pos_order_id = fields.Many2one('pos.order',string="POS order")
	pos_order_line_id = fields.Many2one('pos.order.line',string="POS order Line")
	discount_line_type = fields.Char(related = 'pos_order_line_id.discount_line_type',string='Discount Type',readonly=True,store=True)


	@api.model
	def _get_price_total_and_subtotal_model(self, price_unit, quantity, discount, currency, product, partner, taxes, move_type):
		''' This method is used to compute 'price_total' & 'price_subtotal'.

		:param price_unit:  The current price unit.
		:param quantity:    The current quantity.
		:param discount:    The current discount.
		:param currency:    The line's currency.
		:param product:     The line's product.
		:param partner:     The line's partner.
		:param taxes:       The applied taxes.
		:param move_type:   The type of the move.
		:return:            A dictionary containing 'price_subtotal' & 'price_total'.
		'''
		res = {}
		# Compute 'price_subtotal'.
		if self.discount_line_type and self.discount_line_type == "Fixed":
			price_unit_wo_discount = price_unit - discount
		else:
			price_unit_wo_discount = price_unit * (1 - (discount / 100.0))

		subtotal = quantity * price_unit_wo_discount

		# Compute 'price_total'.
		if taxes:
			taxes_res = taxes._origin.compute_all(price_unit_wo_discount,
				quantity=quantity, currency=currency, product=product, partner=partner, is_refund=move_type in ('out_refund', 'in_refund'))
			res['price_subtotal'] = taxes_res['total_excluded']
			res['price_total'] = taxes_res['total_included']
		else:
			res['price_total'] = res['price_subtotal'] = subtotal

		return res

	
# vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4:   